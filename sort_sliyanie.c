#include <stdlib.h>
#include <stdio.h>
#include <time.h>

int *sort_sliyaniem(int *a, int *b, size_t l, size_t r);

int main()
{
	time_t beg, end;
	srand(time(NULL));
	int n, *arr, i, rand_num, tmp_num;
	scanf("%d", &n);
	if (n <= 1 || n >= 1000) {
		printf("1 < n < 1000\n");
		return 1;
	}
	arr = (int*)malloc(sizeof(int) * n); // делаем массив из n элементов
	for (i = 0; i < n; i++) // инициализируем массив
		arr[i] = i + 1;
	for (i = n - 1; i > 0; i--) { // цикл алгоритма
		rand_num = rand() % i; // получаем случайный номер элемента в массиве
		tmp_num = arr[i]; // меняем местами
		arr[i] = arr[rand_num];
		arr[rand_num] = tmp_num;
	}
	for (i = 0; i < n; i++) { // печатаем результат беспорядка
		printf("%d ", arr[i]);
	}
	putchar('\n');


	// сортировка слиянием
	int *buf = (int*)malloc(sizeof(int) * n); 	// буфер с индентичным размером исходного массива
							// для хранения левой и правой частей
							// из которых, при сравнении, берутся нужные значения для вставки
							// в основной массив.
							// Пример:
							// 1) исходный массив 4 1 3 2
							// 2) после первого прохода до массива с одним элементом и идексом 0,
							// 	в массив buf будет включен этот элемент под тем же индексом,
							// 	потом возврат с возвращением этого массива, теперь левая
							// 	часть указывает на buf {4, 0, 0, 0},
							// 	теперь ищем правую часть, там снова 1 элемент под индексом 1,
							// 	теперь в буфере {4, 1, 0, 0} и правй массив так же указывает на этот buf:
							// 	left_arr = buf и right_arr = buf в итоге;
							// 3) теперь нужно выбрать указатель на наш основной массив,
							// 	в коде функции это выглядит так: t = la == a ? b : a;
							// 	(la есть left_arr, a есть arr (основной массив), b есть buf),
							// 	в котором мы будем менять местами эти элементы (если нужно),
							// 	если левый подмассив
							// 	указывает на буфер (а он указывает, ведь мы вернули его левой части).
							// 	В общем говоря, наша левая и правая часть указывает на другой,
							// 	один и тот же массив, но они разделены своими индексами (у left с 0 по 0,
							// 	у right с 2 по 2).
							// 	if (left_arr = buf) {
							// 		arr_for_now = arr; // сработает это условие
							// 	} else {
							// 		arr_for_now = buf;
							// 	}
							// 	Элс здесь потому что, основной массив и буффер будут чередоваться.
							// 	Тут будет уже выбор из буфера в основной массив с 0 по 1 индекс и возврат
							// 	этого самого нашего уже с одной отсортированной частью массива:
							// 	return arr_for_now; => left_arr выше по стеку теперь указывает на arr.
							// 	Теперь left_arr указывает на {1, 4, 3, 2}
							// 4) Теперь идем вниз для правой части {3, 2}
							// 	То же самое, в итоге buf[2] = 3, а buf[3] = 2
							// 	и left и right в итоге указывают на bufer снова,
							// 	arr_for_now снова указывает на наш основной массив
							// 	и идет выбор из буфера с 2 по 3 индексы в arr_for_now и возврат его 
							// 	в right_arr
							// 5) Теперь и right и left массивы указывают на основной массив {1, 4, 2, 3}
							// 	и тут магия,
							// 	теперь мы arr_for_now делаем указателем на buffer!
							// 	и из основного, получается, массива вытаскиваем интересующие нас
							// 	элементы в нужном порядке и вставляем в buffer и снова возвращаем
							// 	arr_for_now как полностью отсортированный массив {1, 2, 3, 4}.
							// 6) Дальше остается выяснить какой из массивов ненужен и освободить память
							// 	если требуется.
	beg = clock();
	int *new_arr = sort_sliyaniem(arr, buf, 0, n - 1);
	end = clock();
	for (i = 0; i < n; i++) {
		printf("%d ", new_arr[i]);
	}
	putchar('\n');
	printf("time = %.10lfms\n", (double)(end - beg) / CLOCKS_PER_SEC * 1000);
	return 0;
}

int *sort_sliyaniem(int *a, int *b, size_t l, size_t r)
{
	int *la, *ra, *t;
	size_t l_current, r_current, m, i;
	if (l == r) {	// если в массиве один элемент, то мы присваиваем его буферу на ту же позицию, где этот один элемент в основном
			// массиве, с которым вошли в функцию
		b[l] = a[l];
		return b;
	}
	m = l + (r - l) / 2; // получаем индекс серидины массива
	la = sort_sliyaniem(a, b, l, m); // левая часть
	ra = sort_sliyaniem(a, b, m + 1, r); // правая часть
	t = la == a ? b : a;	// если левая часть равна началу текущего массива, который передан в функцию, то началом массива для
				// слияния будет буффер и наоборот
	l_current = l; 	// l_c и r_c нужны для вытягивания элементов из массива, но который указывают левая и правая части. Это могут быть 
			// либо буфер либо основной массив.
	r_current = m + 1;
	for (i = l; i <= r; i++) {
		if (l_current <= m && r_current <= r) {
			if (la[l_current] < ra[r_current]) { // пока в левой части меньше, берем из левой
				t[i] = la[l_current++];
			} else { // пока в правой меньше, берем из правой
				t[i] = ra[r_current++];
			}
		} else if (l_current <= m) { // в правой кончились, добираем из левой
			t[i] = la[l_current++];
		} else { // в левой кончились, добираем из правой
			t[i] = ra[r_current++];
		}
	}
	return t; // возврат набранного
}











